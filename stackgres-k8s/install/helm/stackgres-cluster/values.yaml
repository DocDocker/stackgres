cluster:
  create: true
  postgresVersion: '12.2'
  instances: 1
  sgInstanceProfile: size-xs
  pods:
    persistentVolume:
      size: 5Gi
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      #storageClass: "-"
    disableConnectionPooling: false
    disablePostgresUtil: false
    disableMetricsExporter: false
  configurations:
    sgPostgresConfig: postgresconf
    sgPoolingConfig: pgbouncerconf
    sgBackupConfig: backupconf
  distributedLogs:
    sgDistributedLogs: distributedlogs
  #initialData:
  #  restore:
  #    fromBackup:
  #    downloadDiskConcurrency:
  prometheusAutobind: true

instanceProfiles:
  - name: size-xs
    cpu: "500m"
    memory: "512Mi"
  - name: size-s
    cpu: "1"
    memory: "2Gi"
  - name: size-m
    cpu: "2"
    memory: "4Gi"
  - name: size-l
    cpu: "4"
    memory: "8Gi"
  - name: size-xl
    cpu: "6"
    memory: "16Gi"
  - name: size-xxl
    cpu: "8"
    memory: "32Gi"

configurations:
  create: true
  postgresconfig:
    postgresql.conf:
      shared_buffers: '256MB'
      random_page_cost: '1.5'
      password_encryption: 'scram-sha-256'
      wal_compression: 'on'
      checkpoint_timeout: '30'
  poolingconfig:
    pgBouncer:
      pgbouncer.ini:
        pool_mode: transaction
        max_client_conn: '200'
        default_pool_size: '200'
  backupconfig:
    create: true
    baseBackups:
      retention: 5
      cronSchedule: "*/2 * * * *"
      compression: lz4
      performance:
        uploadDiskConcurrency: 1
        #maxNetworkBandwitdh:
        #maxDiskBandwitdh:
    storage:
      s3: {}
      #  bucket: stackgres
      #  path: /mypath
      #  awsCredentials:
      #    secretKeySelectors:
      #      accessKeyId:
      #        name: awscredentials
      #        key: accesskey
      #      secretAccessKey:
      #        name: awscredentials
      #        key: secretkey
      #  region:
      #  storageClass:
      s3Compatible: {}
      #  bucket: stackgres
      #  path: /mypath
      #  awsCredentials:
      #    secretKeySelectors:
      #      accessKeyId:
      #        name: minio
      #        key: accesskey
      #      secretAccessKey:
      #        name: minio
      #        key: secretkey
      #  region: k8s
      #  endpoint: minio.stackgres.svc
      #  enablePathStyleAddressing: true
      #  storageClass:
      gcs: {}
      #  bucket: stackgres
      #  path: /mypath
      #  gcpCredentials:
      #    secretKeySelectors:
      #      serviceAccountJSON:
      #        name: gcscredentials
      #        key: key
      azureBlob: {}
      #  bucket: stackgres
      #  path: /mypath
      #  azureCredentials:
      #    secretKeySelectors:
      #      storageAccount:
      #        name: azureblobcredentials
      #        key: storageaccount
      #      accessKey:
      #        name: azureblobcredentials
      #        key: accesskey

distributedLogs:
  enabled: false
  create: true
  persistentVolume:
    size: 5Gi
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    #  storageClass: "-"

minio:
  create: true
  persistence:
    enabled: true
    size: 10Gi
  buckets:
    - name: stackgres
      policy: none
      purge: true

#You should only set following options for non production environment
nonProductionOptions:
  disableClusterPodAntiAffinity: true
