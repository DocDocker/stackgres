#!/bin/sh

operator_pull_policy() {
  echo $E2E_OPERATOR_PULL_POLICY
}

install_operator() {
  kubectl get namespace stackgres > /dev/null 2>&1 \
    || kubectl create namespace stackgres

  if [ "$E2E_USE_INTERMIDIATE_PRIVATE_REPO" = true ]
  then
    set_up_private_repo
    install_operator_from_private_repo \
      $E2E_OPERATOR_OPTS "$@"
    return
  fi

  install_operator_vanilla \
    --set-string operator.image.name="${OPERATOR_IMAGE_NAME%:*}" --set-string operator.image.tag="${OPERATOR_IMAGE_NAME#*:}" \
    --set-string restapi.image.name="${RESTAPI_IMAGE_NAME%:*}" --set-string restapi.image.tag="${RESTAPI_IMAGE_NAME#*:}" \
    --set-string "image.pullPolicy=$(operator_pull_policy)" \
    $E2E_OPERATOR_OPTS "$@"
}

install_operator_from_private_repo() {
  export PRIVATE_REPO_URI=$(get_private_repo_uri)
  export PRIVATE_OPERATOR_IMAGE_NAME="$PRIVATE_REPO_URI/stackgres/operator"
  export PRIVATE_RESTAPI_IMAGE_NAME="$PRIVATE_REPO_URI/stackgres/restapi"
  install_operator_vanilla \
      --set-string operator.image.name="$PRIVATE_OPERATOR_IMAGE_NAME" --set-string operator.image.tag="$IMAGE_TAG" \
      --set-string restapi.image.name="$PRIVATE_RESTAPI_IMAGE_NAME" --set-string restapi.image.tag="$IMAGE_TAG" \
      --set-string serviceAccount.repoCredentials="regcred" \
      --set-string "image.pullPolicy=$(operator_pull_policy)" \
      "$@"
}

install_operator_vanilla() {
  helm install stackgres-operator --namespace stackgres "$OPERATOR_CHART_PATH" \
    "$@"
}

set_up_private_repo(){
  if ! aws ecr describe-repositories --repository-name "stackgres/operator" > /dev/null
  then
    aws ecr create-repository --repository-name "stackgres/operator" 
  fi  
  
  if ! aws ecr describe-repositories --repository-name "stackgres/restapi" > /dev/null
  then
    aws ecr create-repository --repository-name "stackgres/restapi" 
  fi  

  export PRIVATE_REPO_URI=$(get_private_repo_uri)
  export PRIVATE_OPERATOR_IMAGE_NAME="$PRIVATE_REPO_URI/$OPERATOR_IMAGE_NAME"
  export PRIVATE_RESTAPI_IMAGE_NAME="$PRIVATE_REPO_URI/$RESTAPI_IMAGE_NAME"

  get_private_repo_password | docker login --username AWS --password-stdin "$PRIVATE_REPO_URI"
  
  docker tag "$OPERATOR_IMAGE_NAME" "$PRIVATE_OPERATOR_IMAGE_NAME"
  docker tag "$RESTAPI_IMAGE_NAME" "$PRIVATE_RESTAPI_IMAGE_NAME"

  docker push "$PRIVATE_OPERATOR_IMAGE_NAME"
  docker push "$PRIVATE_RESTAPI_IMAGE_NAME"

  if kubectl get namespace stackgres > /dev/null
  then  
    kubectl get secret -n stackgres regcred > /dev/null && kubectl delete secret -n stackgres regcred
    kubectl create secret docker-registry -n stackgres regcred \
      --docker-server="$PRIVATE_REPO_URI" \
      --docker-username="AWS" \
      --docker-password="$(get_private_repo_password)"
  else
    kubectl create namespace stackgres
    kubectl create secret docker-registry -n stackgres regcred \
    --docker-server="$PRIVATE_REPO_URI" \
    --docker-username="AWS" \
    --docker-password="$(get_private_repo_password)"
  fi
}

get_private_repo_uri() {
  local AWS_ACCOUNT_ID=$(aws --output=text sts get-caller-identity | awk '{print $1}')
  local AWS_REGION=$(aws configure get region)

  echo "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"
}

get_private_repo_password() {
  echo "$(aws ecr get-login-password)"
}

upgrade_operator() {
  helm upgrade stackgres-operator --namespace stackgres "$OPERATOR_CHART_PATH" --reuse-values "$@"
}

upgrade_or_install_operator() {
  if ! helm get notes stackgres-operator --namespace stackgres > /dev/null
  then
    install_operator "$@"
    return
  fi

  upgrade_operator "$@"
}

delete_operator() {
  ! helm get notes stackgres-operator --namespace stackgres > /dev/null \
    || helm delete stackgres-operator --namespace stackgres "$@" \
    || true
  k8s_cleanup_namespace stackgres
}

get_installed_operator_values() {
  helm get values --namespace stackgres stackgres-operator | tail -n +2
}

store_operator_values() {
  get_installed_operator_values > "$TARGET_PATH/operator-values.yaml"
}

reinstall_operator_if_not_as_expected() {
  if ! helm get notes stackgres-operator --namespace stackgres > /dev/null \
    || [ "$(get_installed_operator_values)" != "$(cat "$TARGET_PATH/operator-values.yaml")" ]
  then
    if ! helm get notes stackgres-operator --namespace stackgres > /dev/null
    then
      echo "Re-installing operator since not installed"
    else
      echo "Re-installing operator since has different values"
      echo
      echo "Values expected:"
      cat "$TARGET_PATH/operator-values.yaml"
      echo
      echo "Values found:"
      get_installed_operator_values
      echo
    fi
    k8s_webhook_cleanup
    helm_cleanup
    k8s_async_cleanup

    kubectl create namespace stackgres
    install_operator_vanilla -f "$TARGET_PATH/operator-values.yaml"
    wait_pods_running stackgres
    if helm get values -n stackgres stackgres-operator | grep -q externalOperatorIp \
      && helm get values -n stackgres stackgres-operator | grep -q externalOperatorPort
    then
      wait_services_available stackgres 2
    else
      wait_services_available stackgres 1
    fi
  fi
}