#!/bin/sh

e2e_test_install() {
  PGCONFIG=postgresconf

  create_or_replace_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE" 1 --set cluster.create=false --set cluster.pgconfig=$PGCONFIG

  deploy_curl_pod "$CLUSTER_NAMESPACE"

  wait_pods_running "$CLUSTER_NAMESPACE" 1

  build_default_config

}

build_default_config() {
  if kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG
  then
    echo "Saving Pgconfig $PGCONFIG"

    CONFIG_FILE=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG  -o json \
     | run_jq 'del(.metadata.creationTimestamp) | del(.metadata.generation) | del(.metadata.resourceVersion) | del(.metadata.selfLink) | del(.metadata.uid)')

    echo "$CONFIG_FILE" > "$LOG_PATH/default-pgconfig.json"
    
    kubectl delete sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG || true
  else
    echo "Pgconfig $PGCONFIG not installed"
    return 1
  fi
    
}

e2e_test_after_all() {
  unset PGCONFIG
}

e2e_test() {
  run_test "Chat that a created pgconfig can be accessed directly through the API" check_pgconfig_directly

  run_test "Check that a created pgconfig is included in the response" check_pgconfig_in_list

  run_test "Check that a pgconfig was removed from the list of pgconfigs after its deletion" check_pgconfig_removed_from_list

  run_test "Check that a pgconfig was removed from direct access after its deletion" check_pgconfig_deletion_directly

  run_test "Postgres config creation through the API" test_pgconfig_create_with_api

  run_test "Check that a pgconfig created with the API is visible" api_created_cluster_visible

  run_test "Postgres config update with the api" test_update_pgconfig_with_api

  run_test "Check that pgconfig changes are reflected in the api" test_api_updated_pgconfig_is_visible

  run_test "Check pgconfig deletion with api" test_delete_pgconfig_with_api

  run_test "Check that pgconfig deletions with the API are reflected in the API" test_api_delete_pgconfig_is_invible
}

create_pgconfig() {
  cat "$LOG_PATH/default-pgconfig.json" | kubectl apply -f -

  while ! kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG
  do
    sleep 2
  done
}

delete_pgconfig_only() {
  echo "Deleting pgconfig if there is any"
  if kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG
  then

    echo "Pgconfig $PGCONFIG found, deleting..."

    kubectl delete sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG

    while kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG
    do
      echo "Pgconfig $PGCONFIG deleted..."
      sleep 2
    done
  else
    echo "No pgconfig found"
  fi
}

check_pgconfig_in_list() {
  create_pgconfig
  local PGCONFIG_IN_RESPONSE

  PGCONFIG_IN_RESPONSE=$(run_curl -r "stackgres/pgconfig" -n $CLUSTER_NAMESPACE | run_jq -c ".[] | select ( .metadata.namespace == \"$CLUSTER_NAMESPACE\") | select ( .metadata.name == \"$PGCONFIG\")" | run_jq '.metadata.name' -r)

  echo "$PGCONFIG_IN_RESPONSE"
  if [ "$PGCONFIG_IN_RESPONSE" = "$PGCONFIG" ]
  then
    echo "Cluster $PGCONFIG included in json response"
    return 0
  else
    echo "Cluster $PGCONFIG not included in json response"
    return 1
  fi
}

get_pgconfig_status() {
  local HTTP_STATUS
  HTTP_STATUS=$(run_curl -r "stackgres/pgconfig/$CLUSTER_NAMESPACE/$PGCONFIG" -n $CLUSTER_NAMESPACE -e "-LI -o /dev/null -w %{http_code}")
  echo $HTTP_STATUS
}

check_pgconfig_directly() {
  local HTTP_STATUS
  create_pgconfig
  HTTP_STATUS=$(get_pgconfig_status)

  if [ $HTTP_STATUS -eq 200 ]
  then
    echo "Postgres config $PGCONFIG was found by the api"
    return 0
  else
    echo "Postgres config $PGCONFIG was not found by the api"
    return 1
  fi
}

check_pgconfig_removed_from_list() {
  delete_pgconfig_only
  local  PGCONFIG_IN_RESPONSE

  PGCONFIG_IN_RESPONSE=$(run_curl -r "stackgres/pgconfig" -n $CLUSTER_NAMESPACE | run_jq -c ".[] | select ( .metadata.namespace = \"$CLUSTER_NAMESPACE\") | select ( .metadata.name = \"$PGCONFIG\")" | run_jq '.metadata.name' -r)

  if [ "$PGCONFIG_IN_RESPONSE" = "$PGCONFIG" ]
  then
    echo "Postgres config $PGCONFIG wasn't removed from cache";
    return 1
  else 
    echo "Postgres config $PGCONFIG was removed from cache";
    return 0
  fi
}

check_pgconfig_deletion_directly() {
  delete_pgconfig_only
  local HTTP_STATUS

  HTTP_STATUS=$(run_curl -r "stackgres/pgconfig/$CLUSTER_NAMESPACE/$PGCONFIG" -n $CLUSTER_NAMESPACE -e "-LI -o /dev/null -w %{http_code}")

  if [ $HTTP_STATUS -eq 404 ]
  then
    echo "Postgres config $PGCONFIG was not found by the api"
    return 0
  else
    echo "Postgres config $PGCONFIG was found by the api"
    return 1
  fi
}

create_pgconfig_with_api() { 
  echo "Creating pgconfig $PGCONFIG with the operator API"

  delete_pgconfig_only

  local HTTP_STATUS

  HTTP_STATUS=$(run_curl -r "stackgres/pgconfig" -n $CLUSTER_NAMESPACE -d "$LOG_PATH/default-pgconfig.json" -e '-X POST -w %{http_code} -o /dev/null')

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "request acknowledged by the operator"
  else
    local ERROR_RESPONSE
    ERROR_RESPONSE=$(run_curl -r "stackgres/pgconfig" -n $CLUSTER_NAMESPACE -d "$LOG_PATH/default-pgconfig.json" -e '-X POST')

    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_pgconfig_create_with_api() {
  create_pgconfig_with_api

  sleep 2

  if kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG
  then
    echo "Postgres config created with the operator API"
  else
    echo "Postgres config wasn't created with the API"
    return 1
  fi
}

api_created_cluster_visible() {
  create_pgconfig_with_api

  check_pgconfig_directly
}

update_pg_config_shared_buffers_with_api() {
  local TMP_JSON
  local HTTP_STATUS

  TMP_JSON=$(mktemp)

  CONFIG=$(cat "$LOG_PATH/default-pgconfig.json" | run_jq ".spec[\"postgresql.conf\"].shared_buffers = $1")
  
  echo "$CONFIG" > "$LOG_PATH/stackgres-pgconfig.json"

  HTTP_STATUS=$(run_curl -r "stackgres/pgconfig" -d "$LOG_PATH/stackgres-pgconfig.json" -e '-X PUT -w %{http_code} -o /dev/null')

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "request acknowledged by the operator"
  else
    local ERROR_RESPONSE
    ERROR_RESPONSE=$(run_curl -r "stackgres/pgconfig" -n $CLUSTER_NAMESPACE -d stackgres-pgconfig.json -e '-X PUT')
    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_update_pgconfig_with_api() {
  local PGCONFIG_SHARED_BUFFERS

  create_pgconfig

  update_pg_config_shared_buffers_with_api '"512MB"'

  PGCONFIG_SHARED_BUFFERS=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG -o "jsonpath={.spec['postgresql\.conf'].shared_buffers}")
  if [ "$PGCONFIG_SHARED_BUFFERS" = "512MB" ]
  then
    echo "Postgres config was updated"
  else
    echo "Postgres config was not updated"
    return 1
  fi
}

get_pgconfig_from_api() {
  echo $(run_curl -r "stackgres/pgconfig/$CLUSTER_NAMESPACE/$PGCONFIG" -n "$CLUSTER_NAMESPACE")
}

test_api_updated_pgconfig_is_visible() {
  local PGCONFIG_SHARED_BUFFERS

  update_pg_config_shared_buffers_with_api '"512MB"'

  PGCONFIG_SHARED_BUFFERS=$(get_pgconfig_from_api | run_jq '.spec["postgresql.conf"].shared_buffers' -r)

  if [ "$PGCONFIG_SHARED_BUFFERS" = "512MB" ]
  then
    echo "Cluster updates are being reflected in the api"
  else
    echo "Cluster updates aren't being reflected in the api"
    return 1
  fi
}

delete_pgconfig_with_api() {
  local HTTP_STATUS

  HTTP_STATUS=$(run_curl -r "stackgres/pgconfig" -n "$CLUSTER_NAMESPACE"  -d "$LOG_PATH/default-pgconfig.json" -e '-X DELETE -w %{http_code} -o /dev/null')

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "request acknowledged by the operator"

  else
    local ERROR_RESPONSE
    ERROR_RESPONSE=$(run_curl -r "stackgres/pgconfig" -n "$CLUSTER_NAMESPACE" -d "$LOG_PATH/default-pgconfig.json" -e '-X PUT')
    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_delete_pgconfig_with_api() {
  create_pgconfig

  delete_pgconfig_with_api

  if wait_until eval '! kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG'
  then
    echo "pgconfig was deleted"
  else
    echo "pgconfig was not deleted"
    return 1
  fi
}

test_api_delete_pgconfig_is_invible() {
  local HTTP_STATUS

  create_pgconfig

  delete_pgconfig_with_api

  if wait_until eval '[ "$(get_pgconfig_status)" = "404" ]'
  then
    echo "Postgres config removed from the API"
  else
    echo "Postgres config removed from the API"
    return 1
  fi
}
