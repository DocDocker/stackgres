#!/bin/sh

test_install() {
  PGPOOLING=pgbouncerconf

  create_or_replace_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE" 1 --set cluster.create=false --set cluster.poolingconfig=$PGPOOLING

  deploy_curl_pod "$CLUSTER_NAMESPACE"

  kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING  -o json \
   | run_jq 'del(.metadata.creationTimestamp) | del(.metadata.generation) | del(.metadata.resourceVersion) | del(.metadata.selfLink) | del(.metadata.uid)'\
    > "$LOG_PATH/default-pgpooling.json"

  kubectl delete sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING
}

test_after_all() {
  unset PGPOOLING
}

test() {
  run_test "Chat that a created pgpooling can be accessed directly through the API" check_pgpooling_directly

  run_test "Check that a created pgpooling is included in the response" check_pgpooling_in_list

  run_test "Check that a pgpooling was removed from the list of pgpoolings after its deletion" check_pgpooling_removed_from_list

  run_test "Check that a pgpooling was removed from direct access after its deletion" check_pgpooling_deletion_directly

  run_test "Pg bouncer config creation through the API" test_pgpooling_create_with_api

  run_test "Check that a pgpooling created with the API is visible" api_created_cluster_visible

  run_test "Pg bouncer config update with the api" test_update_pgpooling_with_api

  run_test "Check that pgpooling changes are reflected in the api" test_api_updated_pgpooling_is_visible

  run_test "Check pgpooling deletion with api" test_delete_pgpooling_with_api

  run_test "Check that pgpooling deletions with the API are reflected in the API" test_api_delete_pgpooling_is_invible
}


create_pgpooling() {
  cat "$LOG_PATH/default-pgpooling.json" | kubectl apply -f -

  while ! kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING
  do
    sleep 2
  done
}

delete_pgpooling_only() {
  echo "Deleting pgpooling if there is any"
  if kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING
  then
    echo "Pgconfig $PGPOOLING found, deleting..."

    kubectl delete sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING

    while kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING
    do
      echo "Pgconfig $PGPOOLING deleted..."
      sleep 2
    done
  else
    echo "No pgpooling found"
  fi
}


check_pgpooling_in_list() {
  create_pgpooling
  local PGPOOLING_IN_RESPONSE

  PGPOOLING_IN_RESPONSE=$(run_curl -r "stackgres/connpoolconfig" -n $CLUSTER_NAMESPACE \
    | run_jq -c ".[] | select ( .metadata.namespace == \"$CLUSTER_NAMESPACE\") | select ( .metadata.name == \"$PGPOOLING\")" | run_jq '.metadata.name' -r)

  echo "$PGPOOLING_IN_RESPONSE"
  if [ "$PGPOOLING_IN_RESPONSE" = "$PGPOOLING" ]
  then
    echo "Cluster $PGPOOLING included in json response"
    return 0
  else
    echo "Cluster $PGPOOLING not included in json response"
    return 1
  fi
}

get_pgpooling_status() {
  local HTTP_STATUS
  HTTP_STATUS=$(run_curl -r "stackgres/connpoolconfig/$CLUSTER_NAMESPACE/$PGPOOLING" -n $CLUSTER_NAMESPACE -e "-LI -o /dev/null -w %{http_code}")
  echo $HTTP_STATUS
}

check_pgpooling_directly() {
  local HTTP_STATUS
  create_pgpooling
  HTTP_STATUS=$(get_pgpooling_status)

  if [ $HTTP_STATUS -eq 200 ]
  then
    echo "Postgres config $PGPOOLING was found by the api"
    return 0
  else
    echo "Postgres config $PGPOOLING was not found by the api"
    return 1
  fi
}



check_pgpooling_removed_from_list() {
  delete_pgpooling_only
  local  PGPOOLING_IN_RESPONSE

  PGPOOLING_IN_RESPONSE=$(run_curl -r "stackgres/connpoolconfig" -n $CLUSTER_NAMESPACE \
    | run_jq -c ".[] | select ( .metadata.namespace = \"$CLUSTER_NAMESPACE\") | select ( .metadata.name = \"$PGPOOLING\")" | run_jq '.metadata.name' -r)

  if [ "$PGPOOLING_IN_RESPONSE" = "$PGPOOLING" ]
  then
    echo "Postgres config $PGPOOLING wasn't removed from cache";
    return 1
  else 
    echo "Postgres config $PGPOOLING was removed from cache";
    return 0
  fi
}

check_pgpooling_deletion_directly() {
  delete_pgpooling_only
  local HTTP_STATUS

  HTTP_STATUS=$(run_curl -r "stackgres/connpoolconfig/$CLUSTER_NAMESPACE/$PGPOOLING" -n $CLUSTER_NAMESPACE -e "-LI -o /dev/null -w %{http_code}")

  if [ $HTTP_STATUS -eq 404 ]
  then
    echo "Postgres config $PGPOOLING was not found by the api"
    return 0
  else
    echo "Postgres config $PGPOOLING was found by the api"
    return 1
  fi
}



create_pgpooling_with_api() { 
  echo "Creating pgpooling $PGPOOLING with the operator API"

  delete_pgpooling_only

  local HTTP_STATUS

  HTTP_STATUS=$(run_curl -r "stackgres/connpoolconfig" -n $CLUSTER_NAMESPACE -d "$LOG_PATH/default-pgpooling.json" -e '-X POST -w %{http_code} -o /dev/null')

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "request acknowledged by the operator"
  else
    local ERROR_RESPONSE
    ERROR_RESPONSE=$(run_curl -r "stackgres/connpoolconfig" -n $CLUSTER_NAMESPACE -d "$LOG_PATH/default-pgpooling.json" -e '-X POST')

    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_pgpooling_create_with_api() {
  create_pgpooling_with_api

  sleep 2

  if kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING
  then
    echo "Postgres config created with the operator API"
  else
    echo "Postgres config wasn't created with the API"
    return 1
  fi
}



api_created_cluster_visible() {
  create_pgpooling_with_api

  check_pgpooling_directly
}


update_pg_config_max_client_conn_with_api() {
  local TMP_JSON
  local HTTP_STATUS

  TMP_JSON=$(mktemp)

  cat "$LOG_PATH/default-pgpooling.json" | run_jq ".spec[\"pgbouncer.ini\"].max_client_conn = $1" > "$TMP_JSON" && mv "$TMP_JSON" "$LOG_PATH/stackgres-pgpooling.json"

  HTTP_STATUS=$(run_curl -r "stackgres/connpoolconfig" -d "$LOG_PATH/stackgres-pgpooling.json" -e '-X PUT -w %{http_code} -o /dev/null')

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "request acknowledged by the operator"
  else
    local ERROR_RESPONSE
    ERROR_RESPONSE=$(run_curl -r "stackgres/connpoolconfig" -n $CLUSTER_NAMESPACE -d stackgres-pgpooling.json -e '-X PUT')
    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_update_pgpooling_with_api() {
  local PGPOOLING_MAX_CONNECTIONS

  create_pgpooling

  update_pg_config_max_client_conn_with_api '400'

  PGPOOLING_MAX_CONNECTIONS=$(kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING -o "jsonpath={.spec['pgbouncer\.ini'].max_client_conn}")
  if [ "$PGPOOLING_MAX_CONNECTIONS" = "400" ]
  then
    echo "Connection pooling config was updated"
  else
    echo "Connection pooling config was not updated"
    return 1
  fi
}

get_pgpooling_from_api() {
  echo $(run_curl -r "stackgres/connpoolconfig/$CLUSTER_NAMESPACE/$PGPOOLING" -n "$CLUSTER_NAMESPACE")
}

test_api_updated_pgpooling_is_visible() {
  local PGPOOLING_MAX_CONNECTIONS

  update_pg_config_max_client_conn_with_api '"512MB"'

  PGPOOLING_MAX_CONNECTIONS=$(get_pgpooling_from_api | run_jq '.spec["pgbouncer.ini"].max_client_conn' -r)

  if [ "$PGPOOLING_MAX_CONNECTIONS" = "512MB" ]
  then
    echo "Cluster updates are being reflected in the api"
  else
    echo "Cluster updates aren't being reflected in the api"
    return 1
  fi
}

delete_pgpooling_with_api() {
  local HTTP_STATUS

  HTTP_STATUS=$(run_curl -r "stackgres/connpoolconfig" -n "$CLUSTER_NAMESPACE"  -d "$LOG_PATH/default-pgpooling.json" -e '-X DELETE -w %{http_code} -o /dev/null')

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "request acknowledged by the operator"

  else
    local ERROR_RESPONSE
    ERROR_RESPONSE=$(run_curl -r "stackgres/connpoolconfig" -n "$CLUSTER_NAMESPACE" -d "$LOG_PATH/default-pgpooling.json" -e '-X PUT')
    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_delete_pgpooling_with_api() {
  create_pgpooling

  delete_pgpooling_with_api

  if wait_until eval '! kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGPOOLING'
  then
    echo "pgpooling was deleted"
  else
    echo "pgpooling was not deleted"
    return 1
  fi
}


test_api_delete_pgpooling_is_invible() {
  local HTTP_STATUS

  create_pgpooling

  delete_pgpooling_with_api

  if wait_until eval '[ "$(get_pgpooling_status)" = "404" ]'
  then
    echo "Pooling config removed from the API"
  else
    echo "Pooling config wasn't removed from the API"
    return 1
  fi
}
