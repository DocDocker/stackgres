#!/bin/sh

e2e_test_install() {
  OPERATOR_NAMESPACE="stackgres"
  PGCONFIG="pgconfig"
  DEFAULT_PGCONFIG="defaultpgconfig"
  PGCBOUNCER="pgbouncer"
  DEFAULT_PGCBOUNCER="defaultpgbouncer"
  DEFAULT_PROFILE="defaultprofile"
  BACKUP_CONFIG="backupconfig"
  DEFAULT_BACKUP_CONFIG="defaultbackupconfig"
  
  kubectl create namespace "$CLUSTER_NAMESPACE"
  deploy_curl_pod "$CLUSTER_NAMESPACE"
  wait_pods_running "$CLUSTER_NAMESPACE" 1
}

e2e_test_uninstall() {
  k8s_cleanup_namespace "$CLUSTER_NAMESPACE"
}

e2e_test(){
  run_test "creating an empty pgconfig should be filled with default configurations" create_empty_pg_config 
  run_test "creating an empty pgbouncer should be filled with default configurations" create_empty_pg_bouncer
  run_test "if default configuration are already created it should create the cluster" create_empty_cluster_with_default_pgbouncer
  run_test "if the sidecars are specifically set to be empty the operator should not add any sidecar" create_empty_cluster_with_no_sidecars
  run_test "creating an empty cluster should trigger the creation of all default configurations" create_empty_cluster
}

create_empty_pg_config(){

  cat << EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1alpha1
  kind: StackGresPostgresConfig
  metadata:
    name: $PGCONFIG
    namespace: $CLUSTER_NAMESPACE
  spec:
    pgVersion: "11"
    postgresql.conf:
      unsignificant: true
EOF

  local CREATED_FIELDS=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG -o json | run_jq '.spec["postgresql.conf"] | length')
  local DEFAULT_FIELDS=$(kubectl get sgpgconfigs.stackgres.io -n $OPERATOR_NAMESPACE $DEFAULT_PGCONFIG -o json | run_jq '.spec["postgresql.conf"] | length')

  if [ $CREATED_FIELDS = $((DEFAULT_FIELDS + 1)) ]
  then
    echo "Success. Defaults fields created"
  else
    echo "Fail. Default fields not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"
  fi

}

create_empty_pg_bouncer(){

  cat << EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1alpha1
  kind: StackGresConnectionPoolingConfig
  metadata:
    name: $PGCBOUNCER
    namespace: $CLUSTER_NAMESPACE
  spec:
    pgbouncer.ini:
      unsignificant: true
EOF

  local CREATED_FIELDS=$(kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCBOUNCER -o json | run_jq '.spec["pgbouncer.ini"] | length')
  local DEFAULT_FIELDS=$(kubectl get sgconnectionpoolingconfigs.stackgres.io -n $OPERATOR_NAMESPACE $DEFAULT_PGCBOUNCER -o json | run_jq '.spec["pgbouncer.ini"] | length')

  if [ $CREATED_FIELDS = $((DEFAULT_FIELDS + 1)) ]
  then
    echo "Success. Defaults fields created"
  else
    echo "Fail. Default fields not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgconnectionpoolingconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCBOUNCER -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"
  fi
}

create_empty_pg_backup_config(){

  cat << EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1alpha1
  kind: StackGresBackupConfig
  metadata:
    name: $BACKUP_CONFIG
    namespace: $CLUSTER_NAMESPACE
  spec:
    compressionMethod=lz4
EOF

  local CREATED_FIELDS=$(kubectl get sgbackupconfigs.stackgres.io -n $CLUSTER_NAMESPACE $BACKUP_CONFIG -o json | run_jq '.spec | length')
  local DEFAULT_FIELDS=$(kubectl get sgbackupconfigs.stackgres.io -n $OPERATOR_NAMESPACE $DEFAULT_BACKUP_CONFIG -o json | run_jq '.spec | length')

  if [ $CREATED_FIELDS = $((DEFAULT_FIELDS + 1)) ]
  then
    echo "Success. Defaults fields created"
  else
    echo "Fail. Default fields not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgbackupconfigs.stackgres.io -n $CLUSTER_NAMESPACE $BACKUP_CONFIG -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"
  fi
}

create_empty_cluster_with_default_pgbouncer(){

  cat <<EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1alpha1
  kind: StackGresCluster
  metadata:
    name: $CLUSTER_NAME-pgbouncer
    namespace: $CLUSTER_NAMESPACE
  spec:
    instances: 1
    pgVersion: '12.1'
    volumeSize: '512Mi'
    sidecars:
    - connection-pooling 

EOF
  
  local CREATED_PGBOUNCER=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-reused" -o=jsonpath={.spec.connectionPoolingConfig})

  if kubectl get sgconnectionpoolingconfigs.stackgres.io -n $OPERATOR_NAMESPACE $CREATED_PGBOUNCER
  then
    echo "Success. Default pgbouncer was created in the cluster namespace"
  else
    echo "Fail. Default pgbouncer was not created in the cluster namespace"
    return 1;
  fi

  cat <<EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1alpha1
  kind: StackGresCluster
  metadata:
    name: $CLUSTER_NAME-reused
    namespace: $CLUSTER_NAMESPACE
  spec:
    instances: 1
    pgVersion: '12.1'
    volumeSize: '512Mi'
    sidecars:
    - connection-pooling 
EOF

  if kubectl get sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-reused"
  then
    echo "Cluster with defaul configuration already created. Succeed"
  else
    echo "Cluster with defaul configuration already created was not created"
    return 1
  fi

}

create_empty_cluster_with_no_sidecars(){
  cat <<EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1alpha1
  kind: StackGresCluster
  metadata:
    name: $CLUSTER_NAME-nosidecars
    namespace: $CLUSTER_NAMESPACE
  spec:
    instances: 1
    pgVersion: '12.1'
    volumeSize: '512Mi'
    sidecars: []
EOF

  if kubectl get sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-nosidecars"
  then
    echo "Cluster with no sidecars. Succeed"
  else
    echo "Cluster with no sidecars was not created."
    return 1
  fi

  local CLUSTER_SIDECARS=$(kubectl get sgclusters.stackgres.io -n $CLUSTER_NAMESPACE $CLUSTER_NAME-nosidecars -o json | run_jq '.spec.sidecars | length')
  
  if [ "$CLUSTER_SIDECARS" = "0" ]
  then
    echo "Success. Specified sidecars were not modified"    
  else
    echo "Fail. Specified sidecars were modified"
    return 1
  fi

}

create_empty_cluster(){

  cat <<EOF | kubectl apply -f -
apiVersion: stackgres.io/v1alpha1
kind: StackGresCluster
metadata:
  name: $CLUSTER_NAME
  namespace: $CLUSTER_NAMESPACE
spec:
  instances: 1
  pgVersion: '12.1'
  volumeSize: '512Mi'
EOF

  local CREATED_PGCONFIG=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" -o=jsonpath={.spec.pgConfig})

  if kubectl get sgpgconfigs.stackgres.io -n $OPERATOR_NAMESPACE $CREATED_PGCONFIG
  then
    echo "Success. Default pgconfig was created in the cluster namespace"
  else
    echo "Fail. Default pgconfig was not created in the cluster namespace"
    return 1;
  fi

  local CREATED_PGCONFIG_FIELDS=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $CREATED_PGCONFIG -o json | run_jq '.spec["postgresql.conf"] | length')
  local DEFAULT_PGCONFIG_FIELDS=$(kubectl get sgpgconfigs.stackgres.io -n $OPERATOR_NAMESPACE $DEFAULT_PGCONFIG -o json | run_jq '.spec["postgresql.conf"] | length')

  if [ "$CREATED_PGCONFIG_FIELDS" = "$DEFAULT_PGCONFIG_FIELDS" ]
  then
    echo "Success. Defaults pgconfig fields were created"
  else
    echo "Fail. Default pgconfig fields not created"
    return 1
  fi

  local CREATED_PROFILE=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" -o=jsonpath={.spec.resourceProfile})

  if kubectl get sgprofiles.stackgres.io -n $OPERATOR_NAMESPACE $CREATED_PROFILE
  then
    echo "Success. Default profile was created in the cluster namespace"
  else
    echo "Fail. Default profile was not created in the cluster namespace"
    return 1;
  fi

  local CREATED_PROFILE_FIELDS=$(kubectl get sgprofiles.stackgres.io -n $CLUSTER_NAMESPACE $CREATED_PROFILE -o json | run_jq '.spec | length')
  local DEFAULT_PROFILE_FIELDS=$(kubectl get sgprofiles.stackgres.io -n $OPERATOR_NAMESPACE $DEFAULT_PROFILE -o json | run_jq '.spec | length')

  if [ "$CREATED_PROFILE_FIELDS" = "$DEFAULT_PROFILE_FIELDS" ]
  then
    echo "Success. Defaults profile fields were created"
  else
    echo "Fail. Default profile fields were not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgclusters.stackgres.io -n $CLUSTER_NAMESPACE $CLUSTER_NAME -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"    
  fi

  local DEFAULT_SIDECARS=$(kubectl get sgclusters.stackgres.io -n $CLUSTER_NAMESPACE $CLUSTER_NAME -o json | run_jq '.spec.sidecars | length')

  if [ "$DEFAULT_SIDECARS" = "3" ]
  then
    echo "Success. Default sidecars were settled"    
  else
    echo "Fail. Default sidecars were not settled"
    return 1
  fi

}