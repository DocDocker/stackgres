{
    "metadata.name": "The name of the StackGres cluster to be created. Following\n[Kubernetes naming conventions](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/identifiers.md),\nit must be an rfc1035/rfc1123 subdomain, that is, up to 253 characters consisting of one or more\nlowercase labels separated by `.`. Where each label is an alphanumeric (a-z, and 0-9) string, with a\nmaximum length of 63 characters, with the `-` character allowed anywhere except the first or last\ncharacter.\n\nThis name needs to be unique across all StackGres clusters in the same namespace. The full cluster name\nwill include the namespace in which the cluster will be created.\n",
    "spec.postgresVersion": "Postgres version to use for the new cluster. It can be either of:\n*  The string 'latest', which will automatically select the latest major.minor Postgres version.\n*  A major version, like '12' or '11', which will select that major version and the latest minor version.\n*  A specific major.minor version, like '12.2'.\n",
    "spec.instances": "Number of StackGres instances to be created. Each instance will contain one Postgres server. Out of all\nof the Postgres servers, one will be elected as the master, the rest will remain as read-only replicas.\n",
    "spec.sgInstanceProfile": "Name of the [SGInstanceProfile](https://stackgres.io/doc/latest/04-postgres-cluster-management/03-resource-profiles/)\nto use. A SGInstanceProfile defines CPU and memory limits. Must exist before creating the cluster. If you\ndon't select a profile, a default (currently: 1 core, 2 GiB RAM) one will be used.\n",
    "spec.pods.persistentVolume.size": "Size of the PersistentVolume to be created for each instance of the cluster. Size must be specified\neither in Mebibytes, Gibibytes or Tebibytes (multiples of 2^20, 2^30 or 2^40, respectively).\n",
    "spec.pods.persistentVolume.storageClass": "Name of an existing StorageClass in the K8s cluster, that will be used to create the PersistentVolumes\nfor the instances of this cluster.\n",
    "spec.pods.disableConnectionPooling": "If is true it disable pgbouncer",
    "spec.pods.disableMetricsExporter": "If is true it disable the prometherus exporter container",
    "spec.pods.disablePostgresUtil": "If is true it disable the postgres-util container",
    "spec.configurations.sgPostgresConfig": "Name of the\n[SGPostgresConfig](https://stackgres.io/doc/latest/04-postgres-cluster-management/02-configuration-tuning/02-postgres-configuration/)\nto use for this cluster. It must exist. If not set, a default Postgres config, for the major version\nselected, will be used.\n",
    "spec.configurations.sgPoolingConfig": "Name of the\n[SGPoolingConfig](https://stackgres.io/doc/latest/04-postgres-cluster-management/02-configuration-tuning/03-connection-pooling-configuration/)\nto use for this cluster. Each pod contains a sidecar with a connection pooler\n(currently: [PgBouncer](https://www.pgbouncer.org/)). The connection pooler is implemented as a sidecar.\nIf not selected, a default configuration will be used. Note that you may disable connection pooling\naltogether by setting to false the disableConnectionPooling property of the pods object.\n",
    "spec.configurations.sgBackupConfig": "Name of the\n[SGBackupConfig](https://stackgres.io/doc/latest/04-postgres-cluster-management/04-backups/)\nto use for this cluster. This will define the backups policy, storage and retention, among others, to\napply to this cluster. If not set, a default backup config will be used.\n",
    "spec.prometheusAutobind": "If enabled, a ServiceMonitor will be created for each Prometheus instance found in order to collect\nmetrics.\n",
    "spec.initialData.restore.fromBackup": "Initialize the cluster data by restoring an existing backup. If not used, cluster will be\ninitialized empty. Set to the UID of an existing\n[SGBackup](https://stackgres.io/doc/latest/04-postgres-cluster-management/04-backups/)\nfrom which to restore the data. The backup needs to be in the same namespace.\n",
    "spec.initialData.restore.downloadDiskConcurrency": "The backup fetch process may fetch several streams in parallel. Specify a value larger than one\nfor parallel fetching.\n",
    "spec.nonProductionOptions.disableClusterPodAntiAffinity": "It is a best practice, on non-containerized environments, when running production workloads, to\nrun each database server on a different server (virtual or physical), i.e., not to co-locate more\nthan one database server per host.\n\nThe same best practice applies to databases on containers. By default, StackGres will not allow to\nrun more than one StackGres pod on a given K8s node. Set this property to true to allow more than\none StackGres pod per node.\n"
  }
  