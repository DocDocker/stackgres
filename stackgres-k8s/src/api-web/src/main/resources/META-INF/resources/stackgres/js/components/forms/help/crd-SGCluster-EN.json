{
  "metadata": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "The name of the StackGres cluster to be created. Following [Kubernetes naming conventions](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/identifiers.md), it must be an rfc1035/rfc1123 subdomain, that is, up to 253 characters consisting of one or more lowercase labels separated by `.`. Where each label is an alphanumeric (a-z, and 0-9) string, with a maximum length of 63 characters, with the `-` character allowed anywhere except the first or last character.\n\nThis name needs to be unique across all StackGres clusters in the same namespace. The full cluster name will include the namespace in which the cluster will be created.\n"
      }
    }
  },
  "spec": {
    "type": "object",
    "properties": {
      "postgresVersion": {
        "type": "string",
        "description": "Postgres version to use for the new cluster. It can be either of:\n*  The string 'latest', which will automatically select the latest major.minor Postgres version.\n*  A major version, like '12' or '11', which will select that major version and the latest minor version.\n*  A specific major.minor version, like '12.2'.\n"
      },
      "instances": {
        "type": "integer",
        "minimum": 1,
        "maximum": 16,
        "description": "Number of StackGres instances to be created. Each instance will contain one Postgres server. Out of all of the Postgres servers, one will be elected as the master, the rest will remain as read-only replicas.\n"
      },
      "sgInstanceProfile": {
        "type": "string",
        "description": "Name of the [SGInstanceProfile](https://stackgres.io/doc/latest/04-postgres-cluster-management/03-resource-profiles/) to use. A SGInstanceProfile defines CPU and memory limits. Must exist before creating the cluster. If you don't select a profile, a default (currently: 1 core, 2 GiB RAM) one will be used.\n"
      },
      "pods": {
        "type": "object",
        "description": "Cluster pod's configuration",
        "properties": {
          "persistentVolume": {
            "type": "object",
            "description": "Pod's persistent volume configuration",
            "properties": {
              "size": {
                "type": "string",
                "pattern": "^[0-9]+(\\.[0-9]+)?(Mi|Gi|Ti)$",
                "description": "Size of the PersistentVolume to be created for each instance of the cluster. Size must be specified either in Mebibytes, Gibibytes or Tebibytes (multiples of 2^20, 2^30 or 2^40, respectively).\n"
              },
              "storageClass": {
                "type": "string",
                "description": "Name of an existing StorageClass in the K8s cluster, that will be used to create the PersistentVolumes for the instances of this cluster.\n"
              }
            },
            "required": [
              "size"
            ]
          },
          "disableConnectionPooling": {
            "type": "boolean",
            "description": "If is true it disable pgbouncer"
          },
          "disableMetricsExporter": {
            "type": "boolean",
            "description": "If is true it disable the prometherus exporter container"
          },
          "disablePostgresUtil": {
            "type": "boolean",
            "description": "If is true it disable the postgres-util container"
          },
          "metadata": {
            "type": "object",
            "description": "Pod custom metadata information",
            "properties": {
              "annotations": {
                "type": "object",
                "description": "Additional annotations for StackGres Pods to have"
              },
              "labels": {
                "type": "object",
                "description": "Additional labels for StackGres Pods to have"
              }
            }
          }
        },
        "required": [
          "persistentVolume"
        ]
      },
      "configurations": {
        "type": "object",
        "description": "Custom configuration to be applied to the cluster.\n",
        "properties": {
          "sgPostgresConfig": {
            "type": "string",
            "description": "Name of the [SGPostgresConfig](https://stackgres.io/doc/latest/04-postgres-cluster-management/02-configuration-tuning/02-postgres-configuration/) to use for this cluster. It must exist. If not set, a default Postgres config, for the major version selected, will be used.\n"
          },
          "sgPoolingConfig": {
            "type": "string",
            "description": "Name of the [SGPoolingConfig](https://stackgres.io/doc/latest/04-postgres-cluster-management/02-configuration-tuning/03-connection-pooling-configuration/) to use for this cluster. Each pod contains a sidecar with a connection pooler (currently: [PgBouncer](https://www.pgbouncer.org/)). The connection pooler is implemented as a sidecar.\n\nIf not selected, a default configuration will be used. Note that you may disable connection pooling altogether by setting to false the disableConnectionPooling property of the pods object.\n"
          },
          "sgBackupConfig": {
            "type": "string",
            "description": "Name of the [SGBackupConfig](https://stackgres.io/doc/latest/04-postgres-cluster-management/04-backups/) to use for this cluster. This will define the backups policy, storage and retention, among others, to apply to this cluster. If not set, a default backup config will be used.\n"
          }
        }
      },
      "initialData": {
        "type": "object",
        "description": "Cluster initialization data options",
        "properties": {
          "restore": {
            "type": "object",
            "properties": {
              "fromBackup": {
                "type": "string",
                "description": "Initialize the cluster data by restoring an existing backup. If not used, cluster will be initialized empty. Set to the UID of an existing [SGBackup](https://stackgres.io/doc/latest/04-postgres-cluster-management/04-backups/) from which to restore the data. The backup needs to be in the same namespace.\n"
              },
              "downloadDiskConcurrency": {
                "type": "integer",
                "minimum": 1,
                "description": "The backup fetch process may fetch several streams in parallel. Specify a value larger than one for parallel fetching.\n"
              }
            }
          }
        }
      },
      "prometheusAutobind": {
        "type": "boolean",
        "description": "If enabled, a ServiceMonitor will be created for each Prometheus instance found in order to collect metrics.\n"
      },
      "nonProductionOptions": {
        "type": "object",
        "properties": {
          "disableClusterPodAntiAffinity": {
            "type": "boolean",
            "description": "It is a best practice, on non-containerized environments, when running production workloads, to run each database server on a different server (virtual or physical), i.e., not to co-locate more than one database server per host.\n\nThe same best practice applies to databases on containers. By default, StackGres will not allow to run more than one StackGres pod on a given K8s node. Set this property to true to allow more than one StackGres pod per node.\n"
          }
        }
      },
      "distributedLogs": {
        "type": "object",
        "description": "Options to distribute cluster logs.",
        "properties": {
          "sgDistributedLogs": {
            "type": "string",
            "description": "Name of the [SGDistributedLogs](https://stackgres.io/doc/latest/04-postgres-cluster-management/06-distributed-logs/) to use for this cluster. It must exists. If not set, logs will be written to stdout.\n"
          }
        }
      }
    },
    "required": [
      "instances",
      "postgresVersion",
      "pods"
    ]
  }
}
